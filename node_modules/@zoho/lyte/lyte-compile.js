Lyte.Compile.debug = true; 
var _LC = LyteComponent;
LyteComponent.needDummyComponentsDiv = true;
LyteComponent.dummyLyteComponentsDiv = document.createElement("div");
LyteComponent.dummyLyteComponentsDiv.setAttribute("id", "dummy-lyte-components-div");
if(!Lyte._ie) {
    if (document.readyState === "complete" || document.readyState === "interactive") {     
        document.body.appendChild(LyteComponent.dummyLyteComponentsDiv);  
    }else{
        document.addEventListener("DOMContentLoaded", function(){
            document.body.appendChild(LyteComponent.dummyLyteComponentsDiv);  
        },true);
    }
}

Lyte.Compile.elifHold=false;
Lyte.Compile.getArgString = function(name, array) {
    var retString;
    for(var i=0;i<array.length;i++) {
        if(typeof array[i] === "object") {
            array[i] = this.getArgString(array[i].value.name, array[i].value.args);
        }
    }
    if(name) {
        retString = name +  "(" + array.toString() + ")";
    } else {
        retString = array.toString();
    }
    return retString;
}
Lyte.Compile.trimAttr = function(tempVal,node,errors){
    var trimmedVal;
    trimmedVal = tempVal.replace(/((const)|(continue)|(default)|(delete)|(do)|(else)|(enum)|(export)|(extends)|(finally)|(for)|(function)|(if)|(import)|(in)|(instanceof)|(new)|(return)|(super)|(switch)|(try)|(typeof)|(var)|(void)|(while)|(with))(?!\w)/g,'__LyteHelper$1__')
    try {
        var expOutput = expHandlers.handleExpression(Espree.parse(trimmedVal), true);
        if(expOutput && (expOutput !== trimmedVal)) {
                expOutput = expOutput.replace(/__LyteHelper(\w*?)__/g,'$1' );
            tempVal = "{{" + expOutput + "}}";
        }
    } catch(e) {
            trimmedVal = trimmedVal.replace(/__LyteHelper(\w*?)__/g,'$1' );
        tempVal = trimmedVal;
        errors.push({message:e.message+node.nodeName +"in the value "+ tempVal});
    }
    return tempVal;
}
// window.pendingComponents = [];

Lyte.Compile.getDynamicNodes =  function(fileName,resolve, templateToRender) {
    window.pending = true;      
    var returnValue,missingComp;
        var s, comp ,errors = [], warnings = [];
        if(templateToRender) {
            comp = templateToRender;
        } else{
            comp = document.querySelector("template[tag-name='"+fileName+"']")
        }
        //console.log("components generating dynamicNodes"+fileName)
        if(!comp) {
            missingComp = fileName;
            errors.push({message :"Cannot find template "+fileName});
            returnValue = {componentName : fileName ,errors : errors,warning : warnings};
        } else {
            s = Lyte._ie? comp : comp.content;
        }
        if(s) {
            this.splitTextNodes(s,warnings);  
            var dynamicNodes = [];
            var strict = comp.getAttribute("use-strict");
            if(strict != null){
                if(s.querySelector("script")){
                    errors.push({message:"Security: Script tags should not be included",strict:true})
                }
                if(s.querySelector("style")){
                    errors.push({message:"Security: Style tags should not be included",strict:true})
                }                 
            }
            var d = [];
            this.newGetDeepNodes(fileName, comp, d, [], undefined, true,errors,warnings);
            this.processTemplate(s,dynamicNodes,fileName,comp.getAttribute("use-strict") !== null,errors,warnings);
            if(errors.length){
                returnValue = {componentName: fileName, errors:errors, warnings:warnings};
            }else{
                returnValue = {componentName : fileName, dynamicNodes : dynamicNodes, _templateAttributes : d[0], template:JSON.stringify(comp.outerHTML)};
            }
        }
        window.pending = false;
        return returnValue;
}
Lyte.Compile.splitTextNodes = function(node,warnings) {
    if(node.tagName === "TABLE" && node.children[0] && node.children[0].tagName !== "TBODY") {
        var table = node.cloneNode();
        var tbody = document.createElement("tbody");
        tbody.innerHTML = node.innerHTML;
        table.appendChild(tbody);
        node.replaceWith(table);
        node = table;
    }
    if(node.hasAttribute) {
        if(node.hasAttribute("lyte-for")) {
            var lyteFor = node.getAttribute("lyte-for");
            var lyteForOptions = {};
            if(node.hasAttribute("lyte-options")) {
                try{
                lyteForOptions = JSON.parse(node.getAttribute("lyte-options"));
                } catch(e) {
                    lyteForOptions = {};
                } 
            }
            var lyteForArr = lyteFor.split(" ");
            var template;
            if(node.tagName === "TEMPLATE") {
                template = node;   
            } else {
                template = document.createElement("template");    
                node.removeAttribute("lyte-for");
                node.removeAttribute("lyte-options");
                template.innerHTML = node.outerHTML;
                node.replaceWith(template);
                node = template;
            }
            node.removeAttribute("lyte-for");
            node.removeAttribute("lyte-options");
            template.setAttribute("items" , lyteForArr[0]);
            template.setAttribute("item", lyteForArr[2] || "item");
            template.setAttribute("index", lyteForArr[3] || "index");
            template.setAttribute("is", "for");
            if(lyteForOptions.unbound) {
                template.setAttribute("unbound", lyteForOptions.unbound);
            }

        } else if(node.hasAttribute("lyte-for-in")) {
            var lyteFor = node.getAttribute("lyte-for-in");
            var lyteForOptions = {};
            if(node.hasAttribute("lyte-options")) {
                try{
                    lyteForOptions = JSON.parse(node.getAttribute("lyte-options"));
                } catch(e) {
                    lyteForOptions = {};
                } 
            }
            var lyteForArr = lyteFor.split(" ");
            var template;
            if(node.tagName === "TEMPLATE") {
                template = node;
                node.removeAttribute("lyte-for-in");
                node.removeAttribute("lyte-options");
            } else {
                template = document.createElement("template");
                node.removeAttribute("lyte-for-in");
                node.removeAttribute("lyte-options");
                template.innerHTML = node.outerHTML;
                node.replaceWith(template);
                node = template;
            }

            template.setAttribute("object" , lyteForArr[0]);
            template.setAttribute("value", lyteForArr[2] || "value");
            template.setAttribute("key", lyteForArr[3] || "key");
            template.setAttribute("is", "forIn");
            if(lyteForOptions.unbound) {
                template.setAttribute("unbound", lyteForOptions.unbound);
            }
        } else if(node.hasAttribute("lyte-if")) {
            var modifiedIf = this.handleLyteIf(node);
            node.replaceWith(modifiedIf);
            node = modifiedIf;
        } else if(node.hasAttribute("lyte-switch")) {
            this.handleLyteSwitch(node);
        }
    }
    if(node && node.childNodes && node.childNodes.length) {
        for(var i=node.childNodes.length-1;i>=0;i--) {
            var chlNode = node.childNodes[i];
            if(chlNode.hasAttribute) {
                if(chlNode.hasAttribute("lyte-if-else") || chlNode.hasAttribute("lyte-else")) {
                    if(!(chlNode.previousElementSibling && (chlNode.previousElementSibling.hasAttribute("lyte-if") || chlNode.previousElementSibling.hasAttribute("lyte-else-if") ) ) ) {
                        warnings.push({message: "Element with lyte-else must be preceded by a element having lyte-if or lyte-else :\n \t" + chlNode.cloneNode().outerHTML})
                    }
                } else {
                    if(node.childNodes[i].getAttribute("case") == "false"){
                        this.elifHold = true;
                    }
                    this.splitTextNodes(node.childNodes[i], warnings);    
                }
            } else {
                this.splitTextNodes(node.childNodes[i], warnings);    
            }            
        }
    }
    if(node.tagName === "TEMPLATE" && !Lyte._ie) {
        this.splitTextNodes((node.content)?node.content:this.createDocFragment(node));
    }
    if(node.nodeType === node.TEXT_NODE) {
    var nodeValue = node.nodeValue;
    if(nodeValue){
    var mustacheValues = nodeValue.match(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g); //'
    if(!mustacheValues) {
                return;
            }
            var newNodeArray = [];
            for(var i=0;i<mustacheValues.length;i++) {
                var mustacheStartIndex = nodeValue.indexOf(mustacheValues[i]);
                var mustacheEndIndex = mustacheStartIndex + mustacheValues[i].length;
                if(mustacheStartIndex) {
                        newNodeArray.push(document.createTextNode(nodeValue.substring(0, mustacheStartIndex)));
                }
                newNodeArray.push(document.createTextNode(nodeValue.substring(mustacheStartIndex, mustacheEndIndex)));
                nodeValue = nodeValue.substring(mustacheEndIndex);
            }
            newNodeArray.push(document.createTextNode(nodeValue));
            node.replaceWith.apply(node, newNodeArray);
        }
    }
}

    //This method will run through all the nodes of the template and put the dynamicNode positions 
    //in deepNodes and helper node positions in helperNodes
    //By helper nodes, we mean all the for and if helpers which are present in the component template. 
    //The template will contain the dynamicNodes. 
    //For template contains - _forTemplate, which will contain the content and _dynamicNodes
    //If template contains - _trueCase, _falseCase, which will contain the content and _dynamicNodes.
    Lyte.Compile.processTemplate = function(node, deepNodes, componentName,strict,errors,warnings){
        var isBreak = node.querySelector('template[is=break]');
        if(isBreak) {
            this.getTrimmedContent(node, undefined, isBreak);
        }
        var isContinue = node.querySelector('template[is=continue]');
        if(isContinue) {
            this.getTrimmedContent(node,undefined, isContinue);
        }
        this.helperNodes = [];
        if(node.hasChildNodes()) {
            var runningIndex = 0;
            for(var i=0;i<node.childNodes.length;i++) {
                var deepN = [];
                deepN.push(i);
                var index = 0;
                if(node.childNodes[i].tagName) {
                    var tagName = node.childNodes[i].tagName;
                    var is = node.childNodes[i].getAttribute("is");
                    if(tagName === "TEMPLATE" && is) {
//                        index = helperNodes.push(node.childNodes[i]);
                        //We will be adding an attribute index1 in the helper templates, 
                        //This is done because we will be storing all the helper nodes as such in an array _helperNodes in the component template. 
                        //In order to lookup to the dynamicNodes of the for template or if template, we need to have a reference of which 
                        //helper we are calling. 
                        //By this way, we will be adding an index1 Attribute which will contain index startign from 0. 
                        //This index refreshes for each component registration. 
//                        node.childNodes[i].setAttribute("index1", index-1);
                        this.newGetDeepNodes(componentName,node.childNodes[i], deepNodes, deepN, is,strict,errors,warnings);
                    }
                    else {
                        this.newGetDeepNodes(componentName,node.childNodes[i], deepNodes, deepN,undefined,strict,errors,warnings);
                    }
                } else {
                    this.newGetDeepNodes(componentName,node.childNodes[i], deepNodes, deepN,undefined,strict,errors,warnings);
                }
            }
        }
    
    }
    //This method is the place where the deepNodes and helperNodes gets updated with the 
    //Values of the positions of dynamicNodes and helperNodes. 
    Lyte.Compile.newGetDeepNodes =  function(componentName,node, deepNodes, deepN, is,strict,errors,warnings) {
        var toBePushed;
        var errorMsg = "Usage of block helpers (for|forIn|if|switch) inside the tags (TABLE|TR|SELECT) will not work in IE11. \n If your app is supported for IE11, please use lyte ui components lyte-table and lyte-dropdown instead of table and select tags respectively";
        if(node.nodeType == 8){
            deepN.pop();
            return;
        }
        if(node.tagName && node.tagName.indexOf("-") !== -1 && node.tagName !== "LYTE-YIELD") {
            toBePushed = {"type" : "componentDynamic", position: deepN.slice()};
        }
        if(node.tagName === "LYTE-YIELD") {
            toBePushed = {"type" : "insertYield", position : deepN.slice()};
        } else 
        if(is === "registerYield" || is === "yield") {
            var dynamicNodes = [];
            this.processTemplate(Lyte._ie ? node : node.content, dynamicNodes, componentName,strict,errors,warnings);
            toBePushed = {"type" : "registerYield", position: deepN.slice(), "dynamicNodes" : dynamicNodes};
        } else if(is === "insertYield") {
            deepNodes.push({"type" : "insertYield", position : deepN.slice()});
        } else 
        if(is === "for") {
            node._forTemplate = {};
            var template = node;
            if(template) {
                node._forTemplate.content = template.content;
                var dynamicNodes = [];
                this.processTemplate(Lyte._ie ? node._forTemplate : node._forTemplate.content, dynamicNodes, componentName,strict,errors,warnings);
                toBePushed = {"type": "for" ,position: deepN.slice(), "dynamicNodes":dynamicNodes};
                node = this.replaceParentNode(node, "for", toBePushed);
            }
        } else if(is === "forIn"){
            node._forInTemplate = {};
            var template = node;
            if(template) {
                node._forInTemplate.content = template.content;
                var dynamicNodes = [];
                this.processTemplate(Lyte._ie ? node._forInTemplate : node._forInTemplate.content, dynamicNodes ,componentName,strict,errors,warnings);
                toBePushed = {"type": "forIn" ,position: deepN.slice(), "dynamicNodes":dynamicNodes};
            }
            node = this.replaceParentNode(node, "forIn", toBePushed);
        }
        else if(is === "switch" || is === "if"){
            var casesArr = {},defaultArr = {};
            var defaultCase = node.content.querySelector("[default]");
            var cases = node.content.querySelectorAll("[case]");
            var currentCaseTemplate;
            for(var i=0;i<cases.length;i++){
                var currentCase = cases[i];
                currentCaseTemplate = cases[i];
                var caseName = currentCase.getAttribute("case");
                if(is === "switch" && caseName == ""){
                    caseName = "\"\"";
                }
                if(currentCase.tagName === "TEMPLATE" && !currentCase.getAttribute("is")){
                    currentCase.setAttribute("case", caseName );
                    currentCase = currentCase.content;
                } 
                else {
                    var temp = document.createElement('template');
                    var clone = currentCase.cloneNode(true);
                    temp.content.appendChild(clone);
                    temp.setAttribute("case", caseName );
                    clone.removeAttribute('case');
                    currentCaseTemplate = temp;
                    currentCase = temp.content;
                    cases[i].replaceWith(temp);
                }
                var dynamicNodes = [];
                this.processTemplate(currentCase, dynamicNodes, componentName,strict,errors,warnings);
                if(is === "if") {
                    this.replaceCaseNode(currentCaseTemplate);    
                }
                if(caseName === "") {
                    caseName = '""';
                }
                casesArr[caseName] = {dynamicNodes: dynamicNodes};
                if(is==="if") {
                    continue;
                }
                var isBreak = currentCase.querySelector("template[is=break]");
                if(!isBreak) {
                    if(cases[i+1]) {
                        casesArr[caseName].additional = {"next" : cases[i+1].getAttribute("case")};
                    } else if(defaultCase){
                        casesArr[caseName].additional = {"default" : true};
                    }
                }
                else {
                    isBreak.remove();
                }
                this.replaceCaseNode(currentCaseTemplate);
            }
            if(defaultCase){               
                var dCase;     
                var dCaseTemplate;               
                if(defaultCase.tagName === "TEMPLATE" && !defaultCase.getAttribute("is")){               
                    dCase = defaultCase.content;        
                    dCaseTemplate = defaultCase;          
                    }           
                else {        
                    var temp = document.createElement('template');             
                    var clone = defaultCase.cloneNode(true);            
                    temp.content.appendChild(clone);     
                    temp.setAttribute("default", '');     
                    clone.removeAttribute('default');             
                    dCase = temp.content;          
                    dCaseTemplate = temp;     
                    defaultCase.replaceWith(temp);      
                }
                var isBreak = dCaseTemplate.content.querySelector("template[is=break]");
                if(isBreak){
                    isBreak.remove();
                }     
                var dynamicNodes = [];           
                this.processTemplate(dCase, dynamicNodes, componentName,strict,errors,warnings);     
                defaultArr = {dynamicNodes: dynamicNodes};    
                this.replaceCaseNode(dCaseTemplate);              
            }
            toBePushed = {"type": is, position: deepN.slice(),"cases":casesArr,"default":defaultArr};
            node = this.replaceParentNode(node, is, toBePushed);
        } else if(is==="component") {
            node._componentTemplate = {};
            node._componentTemplate.content = node.content;
            var dynamicNodes = [];
            this.processTemplate(node._componentTemplate.content, dynamicNodes, componentName,strict,errors,warnings);
            toBePushed = {"type" : "component", position: deepN.slice(), "dynamicNodes" : dynamicNodes};
        }
        else if(node.nodeType == 3) {
            if(node.nodeValue.indexOf("{{") !== -1) {
                var val = node.nodeValue;
                //need option
                if(typeof Espree !== 'undefined' && typeof expHandlers !== 'undefined'){
                    var x,tempVal;
                        tempVal = val.match(/{{[^}]*?(?:(?:[^\1]*?\1)[^}]*?)*}}/g);
                        if(tempVal){
                        for(var j=0;j < tempVal.length;j++){ 
                            x = this.trimAttr(tempVal[j],node,errors);
                            val = val.replace(tempVal[j],x);
                        }
                        node.nodeValue = val;
                    }
                }
                var mustache =  this.getMustache(node.nodeValue),dynamicValue,helperFunc;
                if(mustache && typeof mustache === 'object'){
                    if(mustache.bool === false){
                    errors.push({message:"Syntax error in node "+mustache.err+" in "+node.nodeName+" for the attribute: "+node.nodeName+" - "+node.nodeValue +" in the component "+componentName});
                    }
                }
                if(mustache){
                        helperFunc =  this.getHelper(mustache);
                        if(helperFunc === false){
                            errors.push({message:"Syntax Error in node "+node.nodeName+"for :"+node.nodeValue +" in the component "+componentName});
                            return;
                        }
                } else {
                    errors.push({message:"Syntax Error in node "+node.nodeName+"for :"+node.nodeValue +" in the component "+componentName});
                }    
                var dynamic = mustache;
                if(helperFunc){
                    if(window.newBuild) {
                        deepNodes.push({type: "text", position:deepN.slice()/*, helperInfo: helperFunc*/}); 
                    } else {
                        deepNodes.push({type: "text", position:deepN.slice(), helperInfo: helperFunc}); 
                    }
                    
                }
                else if(dynamic){
                    if(window.newBuild) {
                        deepNodes.push({type: "text", position:deepN.slice()/*, dynamicValue: dynamic*/});
                    } else {
                        deepNodes.push({type: "text", position:deepN.slice(), dynamicValue: dynamic});
                    }
    //                  LN to do
    //                  deepNodes.push({type: "text", position:deepN.slice(), dynamicValue: getDynamicValue(dynamic)});                    
                }
            }
            deepN.pop();
            return;
        }
        if(node.hasAttributes && node.hasAttributes()) { //template has no attributes
            var add = false, toBeRemoved = [],attr = {},toBeAdded = [];
            for(var i=0;i<node.attributes.length;i++) {
                if(node.attributes[i].nodeValue.indexOf("{{") !== -1) {
                    var val = node.attributes[i].nodeValue;
                    //need option
                    if(typeof Espree !== 'undefined' && typeof expHandlers !== 'undefined'){
                    tempVal = val.match(/{{[^}]*?(?:(?:[^\1]*?\1)[^}]*?)*}}/g);
                        if(tempVal){
                        for(var j=0;j < tempVal.length;j++){ 
                            x = this.trimAttr(tempVal[j],node,errors);
                            val = val.replace(tempVal[j],x);
                        }
                        node.attributes[i].nodeValue = val;
                    }
                }
                    var actValue =  this.getMustache(val), actObj ;
                    if(actValue && typeof actValue === 'object'){
                        if(actValue.bool === false){
                        errors.push({message:"Syntax error in node "+actValue.err+" in "+node.nodeName+" for the attribute: "+node.attributes[i].nodeName+" - "+node.attributes[i].nodeValue +" in the component "+componentName});
                        continue;
                        }
                    }
                    if(actValue){
                        actObj =  this.getHelper(actValue);  
                        if(actObj === false){
                            errors.push({message:"Syntax error in node "+node.nodeName+" for the attribute:"+node.attributes[i].nodeName+"- "+node.attributes[i].nodeValue});
                            continue;
                        }
                    }
                    else if(/{{.*}}/.test(val) && !(/\\{{.*}}/.test(val))){
                        actObj =  this.splitMixedText(val);
                    }
                    if( actObj && (actObj.name === "action" || actObj.name === "method") && /^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onmouseenter|onmouseleave|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu)$/.test(node.attributes[i].name)){
                            add = true;
                            attr[node.attributes[i].name.substr(2)] = {name:node.attributes[i].name.substr(2),helperInfo: actObj, globalEvent: true};
                            var actArgs = this.deepCopyObject(actObj.args);
                            var actName = actArgs.splice(0,1)[0];
                            if (typeof actName != 'string' || !actName.startsWith("'")){
                                errors.push({message:" action or method must start with string on "+node.nodeName+" for the attribute:"+node.attributes[i].nodeName+"- "+node.attributes[i].nodeValue});
                            }
                            else{
                            actName = actName.startsWith("'")? actName.replace(/'/g,''):  actName;
                            }
                            var actString = this.getArgString(actName, actArgs);
                            if(!window.newBuild) {
                                node.setAttribute(node.attributes[i].name.substr(2),componentName+" => "+ actString);
                            } 
                            //node.setAttribute(node.attributes[i].name.substr(2),componentName+" => "+ actString);
                            toBeRemoved.push(node.attributes[i].name);                            
                    }
                    else{
                        if(actObj || actValue) {
                            add = true;
                            var attrToPush = {};
                            if(node.attributes[i].name.startsWith("lbind:")) {
                                toBeRemoved.push(node.attributes[i].name);
                                toBeAdded.push({"name" : node.attributes[i].name.substring(6), "value": node.attributes[i].nodeValue});
                                attrToPush.isLbind = true;
                                attrToPush.name = node.attributes[i].name.substring(6);
                            }
                            else {
                                attrToPush.name = node.attributes[i].name;
                            }
                            if(actObj) {
                                if(actObj.name === "lbind") {
                                    attrToPush.dynamicValue = actObj.args[0];
                                    attrToPush.isLbind = true;
                                }
                                else {
                                    attrToPush.helperInfo = actObj;
                                }
                            } 
                            else {
                                attrToPush.dynamicValue = actValue;
    //                              LN to do
    //                              attrToPush.dynamicValue = getDynamicValue(actValue);
                            }
                            add = true;
                            attr[attrToPush.name] = attrToPush;
                        }                  
                    }
                }
                else {
                    if(/^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onmouseenter|onmouseleave|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu|ondragstart|ondrag|ondragenter|ondragleave|ondragover|ondrop|ondragend|onload|onunload|onabort|onerror|onscroll|onreset|onblur)$/.test(node.attributes[i].nodeName) && strict){
                                errors.push({message:"Strict-Mode: Please specify action in "+node.nodeName+" for attribute-"+node.attributes[i].nodeName,strict:true});
    
                    }  else if((/{.*}/.test(node.attributes[i].nodeValue))){
                        try {
                            JSON.parse(node.attributes[i].nodeValue);
                        } catch(e) {
                            warnings.push({message:"Syntax error in node "+node.nodeName+" for the attribute:"+node.attributes[i].nodeName+"- "+node.attributes[i].nodeValue +" in the component "+componentName});
                            
                        }
                    
                    }  else if((/{.*:/.test(node.attributes[i].nodeValue)) || (/{/.test(node.attributes[i].nodeValue))) {
                        try {
                            JSON.parse(node.attributes[i].nodeValue);
                        } catch(e) {                            
                            errors.push({message:"Syntax error in node "+node.nodeName+" for the attribute:"+node.attributes[i].nodeName+"- "+node.attributes[i].nodeValue +" in the component "+componentName});
                            continue;
                        }
                    }   
                }
            }
            if(!window.newBuild) {
                if(toBeRemoved.length){
                    for(var i=0; i<toBeRemoved.length;i++){
                        node.removeAttribute(toBeRemoved[i]);
                    }
                }
                if(toBeAdded.length) {
                    for(var i=0;i<toBeAdded.length;i++) {
                        node.setAttribute(toBeAdded[i].name, toBeAdded[i].value);
                    }
                }
            }
            
            if(attr && add){
                if(window.newBuild) {
                    var dummyAttr = {}; 
                    var keys = Object.keys(attr);
                    if(keys.indexOf("style") !== -1) {
                        dummyAttr.style = attr.style;
                    }
                    if(keys.indexOf("type") !== -1 && (node.tagName === "BUTTON" || node.tagName === "INPUT")) {
                        dummyAttr.type = attr.type;
                    }
                    if(node.tagName === "INPUT" && node.getAttribute("type") === "number") {
                        dummyAttr.value = attr.value;   
                    }
                    if(Object.keys(dummyAttr).length) {
                        deepNodes.push({"type": "attr", position: deepN.slice(), "attr" : dummyAttr});    
                    } else {
                        deepNodes.push({"type": "attr", position: deepN.slice()});        
                    }   
                } else {
                    deepNodes.push({"type": "attr", position: deepN.slice(), "attr": attr});                
                }
            }
        }
    
        if( node.hasChildNodes() && node.tagName !== "TEMPLATE"){
            for(var i=0;i<node.childNodes.length;i++) {
                deepN.push(i);
                if(node.childNodes[i].tagName) {
                    var tagName = node.childNodes[i].tagName;
                    var is = node.childNodes[i].getAttribute("is");
                    if(tagName && is) {
                        this.newGetDeepNodes(componentName, node.childNodes[i], deepNodes, deepN, is ,strict,errors,warnings);
                    }
                    else {
                        this.newGetDeepNodes(componentName, node.childNodes[i], deepNodes, deepN,undefined,strict,errors,warnings);
                    }
                } 
                else {
                    this.newGetDeepNodes(componentName, node.childNodes[i], deepNodes, deepN,undefined,strict,errors,warnings);
                }
            }
        } 
        
        if(toBePushed) {
            deepNodes.push(toBePushed);
        }
        deepN.pop();
    }
    Lyte.Compile.createDocFragment = function(template){
        var childNodes = template.cloneNode(true).childNodes;
        var frag = document.createDocumentFragment();
        var len = childNodes.length;
        for(var i=0; i<len; i++){
            frag.appendChild(childNodes[0]);
        }
        return frag;
    }
    Lyte.Compile.getDynamicValue = function(value){    
        var result = [],ref = result,arr = [],data = "",strStack = [],arrayStack = [],refStack = [],strLast,str;
        for(var i=0;i<value.length;i++){
            if(value[i] === "."){
                if(data.length){
                    ref.push(data);
                }
                data = "";
                continue;
            }
            else if(value[i] === "["){
                arrayStack.push(i)
                if(data.length){
                    ref.push(data);
                }
                while(value[i+1] === "\s"){
                    i++;
                }
                if(value[i+1] === "\"" || value[i+1] === "'"){
                    strStack.push(value[i+1]);
                    strLast = value[i+1];
                    i++;
                }
                else if(arr.length){
                    ref.push([]);
                    refStack.push(ref);
                    ref = ref[ref.length-1];
                }else{
                    arr.push([]);
                    refStack.push(ref);
                    ref = arr[arr.length-1];
                }
                data = "";
                continue;
            }
            else if((value[i] === "\"" || value[i] === "'" ) && value[i++] === strLast){
                while(value[i] === "\s" && value[i] != "]"){
                    i++;
                }
                strStack.pop();
                str = true;
            }
            if(value[i] === "]"){
                arrayStack.pop();
                if(data.length){
                    if(str === true){
                        ref.push(data);    
                    }
                    else if(!isNaN(parseInt(data))){
                        if(refStack.length){
                            ref = refStack.pop();
                            if(arr.length && Array.isArray(ref[ref.length-1]) && !ref[ref.length-1].length){
                                ref.pop();
                            }
                            ref.push(data);
                            if(!arrayStack.length && arr.length){
                                arr.shift();
                            }
                        }
                    }
                    else{
                        ref.push(data);
                    }
                }
                if(!arrayStack.length && arr.length){
                    result.push(arr.shift());
                    ref = result;
                }
                else if(refStack.length && !arr.length){ 
                    ref = refStack.pop();
                }
                data = "";
                str = "";
                continue;
            }
            data = data.concat(value[i]);
        }
        if(data.length){
            result.push(data);
        }
        if(strStack.length || arrayStack.length){
        }
        return result;
    }
    Lyte.Compile.deepCopyObject = function( obj )  {
        var current, copies = [{source : obj, target : Object.create(Object.getPrototypeOf(obj))}], keys, propertyIndex, descriptor, nextSource, indexOf, sourceReferences = [obj];
        var cloneObject = copies[0].target, targetReferences = [cloneObject];
        while(current = copies.shift()){
            keys = Object.getOwnPropertyNames(current.source);
            for(propertyIndex = 0; propertyIndex < keys.length; propertyIndex++){
                descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);
                if(!descriptor.value || typeof descriptor.value != "object"){
                    Object.defineProperty(current.target, keys[propertyIndex], descriptor);
                    continue;
                }
                  nextSource = descriptor.value;
                  descriptor.value = Array.isArray(nextSource) ? [] : Object.create(Object.getPrototypeOf(nextSource));
                  indexOf = sourceReferences.indexOf(nextSource);
                  if(indexOf != -1){
                      descriptor.value = targetReferences[indexOf];
                      Object.defineProperty(current.target, keys[propertyIndex], descriptor);
                      continue;
                  }
                  sourceReferences.push(nextSource);
                  targetReferences.push(descriptor.value);
                  Object.defineProperty(current.target, keys[propertyIndex], descriptor);
                  copies.push({source : nextSource, target : descriptor.value});
              }
          }
        return cloneObject;
    }

    Lyte.Compile.replaceCaseNode = function(node) {
        var tagName;
        var template;
        for(var i=0;i<node.content.children.length;i++) {
            if(node.content.children[i].tagName !== "TEMPLATE") {
                if(/^(TR|TD|TH)$/.test(node.content.children[i].tagName)) {
                    tagName = node.content.children[i].tagName;
                }
                break;
            }
        }
        if(tagName) {
            if(tagName === "TR") {
                template = node.cloneNode();
                template.innerHTML = "<table><tbody>" + node.innerHTML + "</tbody></table>";
                template.setAttribute("depth", 2);
    
            } else {
                template = node.cloneNode();
                template.innerHTML = "<table><tbody><tr>" + node.innerHTML + "</tr></tbody></table>";
                template.setAttribute("depth", 3);
            }
            node.replaceWith(template);
        }
    }
    Lyte.Compile.replaceParentNode = function(node, type, toBePushed) {
        if(!node.parentElement) {
            return node;
        }
        var parentElementName = node.parentElement.tagName;
        var newElementName;
        var templateNode = node.cloneNode();
        if(node.parentElement && /^(SELECT|TR|TABLE|TBODY)$/.test(parentElementName)) {
            switch(parentElementName) {
                case "SELECT" : 
                    newElementName = "option";
                break;
                case "TR" : 
                    templateNode.innerHTML = "<table><tbody><tr>" + node.innerHTML + "</tr></tbody></table>"
                    templateNode.setAttribute("depth", 3);
                    newElementName = "td";
                break;
                case "TABLE" : 
                case "TBODY" : 
                    templateNode.innerHTML = "<table><tbody>" + node.innerHTML + "</table></tbody>";
                    templateNode.setAttribute("depth", 2);
                    newElementName = "tr";
                break;
            }
            var newElement = document.createElement(newElementName);
            var parentElement = document.createElement(parentElementName);
            switch(type) {
                case "for" : 
                    newElement.setAttribute("is", "for");
                    newElement.setAttribute("lyte-for", "true");
                    if(node.hasAttribute("unbound")) {
                        newElement.setAttribute("unbound", node.getAttribute("unbound"));
                    }
                    // newElement.setAttribute("items", node.getAttribute("items"));
                    // newElement.setAttribute("item", node.getAttribute("item"));
                    // newElement.setAttribute("index", node.getAttribute("index"));
                break;
                case "if" :
                case "switch" :  
                    newElement.setAttribute("is", type);
                    newElement.setAttribute("lyte-"+type, "true");
                    //newElement.setAttribute("value", node.getAttribute("value"));
                break;
                case "forIn" : 
                    newElement.setAttribute("is", "forIn");
                    newElement.setAttribute("lyte-forIn", "true");
                    if(node.hasAttribute("unbound")) {
                        newElement.setAttribute("unbound", node.getAttribute("unbound"));
                    }
                    // newElement.setAttribute("object", node.getAttribute("object"));
                    // newElement.setAttribute("key", node.getAttribute("key"));
                    // newElement.setAttribute("value", node.getAttribute("value"));
                break;
            }
            var attrs = node.attributes;
            for(var i=0;i<attrs.length;i++) {
                newElement.setAttribute(attrs[i].nodeName, attrs[i].nodeValue);
            }
            if(parentElementName !== "SELECT" && (type === "for" || type === "forIn")) {
                toBePushed.actualTemplate = templateNode.outerHTML;  
                toBePushed.tagName = parentElementName;  
                if(templateNode.hasAttribute("depth")) {
                    newElement.setAttribute("depth" , templateNode.getAttribute("depth"));
                }
    
            } else {
                toBePushed.actualTemplate = node.outerHTML;
            }
            node.replaceWith(newElement);
            return newElement;
        }
        return node;
    }
    Lyte.Compile.siblingNullCheck = function(nextSibling){
        if(nextSibling.previousSibling.nodeValue === null || nextSibling.nextSibling.nodeValue === null){
            return null;
        }
        else{
            return 1;
        }
    }
    Lyte.Compile.handleLyteIf = function(element) {
        var ifStmt;
        if(element.hasAttribute("lyte-if")) {
            ifStmt = element.getAttribute("lyte-if");
            element.removeAttribute("lyte-if");
        } else if(element.hasAttribute("lyte-else-if")) {
            ifStmt = element.getAttribute("lyte-else-if");
            element.removeAttribute("lyte-else-if");
        }
        var temp = document.createElement("template");
        temp.setAttribute("is", "if");
        temp.setAttribute("value", ifStmt);
        if(this.elifHold){
            temp.setAttribute("el", true);
            this.elifHold =false;
        }
        //True case done
        var trueTemp;
        if(element.tagName === "TEMPLATE") {
            trueTemp = element.cloneNode();
            trueTemp.innerHTML = element.innerHTML;
        } else {
            trueTemp = document.createElement("template");
            trueTemp.innerHTML = element.outerHTML;
        }
        temp.content.appendChild(trueTemp);
        trueTemp.setAttribute("case", "true");
    
        //Else case handling
        if(element.nextElementSibling) {
            var nextSibling = element.nextElementSibling;
            var falseTemp;
            var type;
            if(nextSibling.hasAttribute("lyte-else")) {
                type = "lyte-else";
            } else if(nextSibling.hasAttribute("lyte-else-if")) {
                type = "lyte-else-if";
            }
            if(type) {
                //falseTemp = document.createElement("template"); 
                //falseTemp.setAttribute("case", "false");
                if(type === "lyte-else") {
                    nextSibling.removeAttribute("lyte-else");
                    if(nextSibling.tagName === "TEMPLATE") {
                        falseTemp = nextSibling.cloneNode();
                        falseTemp.innerHTML = nextSibling.innerHTML;
                    } else {
                        falseTemp = document.createElement("template");
                        falseTemp.setAttribute("case", "false");
                        falseTemp.innerHTML = nextSibling.outerHTML;
                    }
                    falseTemp.setAttribute("case", "false");
                    if(this.siblingNullCheck(nextSibling) && nextSibling.previousSibling && nextSibling.nextSibling && (nextSibling.nextSibling.nodeValue.trim() === "") && ("" === nextSibling.previousSibling.nodeValue.trim())) {
                        nextSibling.nextSibling.remove();
                    }
                    nextSibling.remove();
                } else {
                    falseTemp = document.createElement("template");
                    falseTemp.setAttribute("case", "false");
                    falseTemp.innerHTML = this.handleLyteIf(nextSibling).outerHTML;
                    if(this.siblingNullCheck(nextSibling) && nextSibling.previousSibling && nextSibling.nextSibling && (nextSibling.nextSibling.nodeValue.trim() === "") && ("" === nextSibling.previousSibling.nodeValue.trim())) {
                        nextSibling.nextSibling.remove();
                    }
                    nextSibling.remove();
    
                }
                temp.content.appendChild(falseTemp);
            }
        }
        return temp;
    }
    
    Lyte.Compile.handleLyteSwitch = function(node) {
        var template;
        var switchValue = node.getAttribute("lyte-switch");
        var childElements;
        var type;
        if(node.tagName === "TEMPLATE") {
            template = node;
            template.removeAttribute("lyte-switch");
            childElements = Array.from(template.content.children);
            type = "template";
        } else {
            node.removeAttribute("lyte-switch");
            template = document.createElement("template");
            template.setAttribute("nt",true);
            childElements = Array.from(node.children);
        }
        var cases = {};
        
        for(var i=0;i<childElements.length;i++) {
            var child = childElements[i];
            if(child.hasAttribute("lyte-case")) {
                var isChildTemplate = child.tagName === "TEMPLATE";
                //var childTemplate = isChildTemplate ? child : document.createElement("template");
                var childTemplate = child;
                var hasBreak = child.hasAttribute("lyte-break");
                var caseValue = child.getAttribute("lyte-case");
    
                child.removeAttribute("lyte-case");
                child.removeAttribute("lyte-break");
                if(child.hasAttribute("lyte-if")) {
                    isChildTemplate = false;
                    child = this.handleLyteIf(child);
                } else if(child.hasAttribute("lyte-switch")) {
                    isChildTemplate = false;
                    this.handleLyteSwitch(child);
                }
                if(isChildTemplate) {
                    template.content.appendChild(child);
                    child.setAttribute("case", caseValue);
                    child.removeAttribute("lyte-case");
                } else {
                    childTemplate = document.createElement("template");
                    childTemplate.setAttribute("case", caseValue);
                    child.removeAttribute("lyte-case");
                    childTemplate.content.appendChild(child);
                    template.content.appendChild(childTemplate);
                    
                }
                if(hasBreak) {
                    var breakTemp = document.createElement("template");
                    breakTemp.setAttribute("is", "break");
                    childTemplate.content.appendChild(breakTemp);
                    child.removeAttribute("lyte-break");
                }
            }
        }
        var defaultCase = type ? node.content.querySelector("[lyte-default]") : node.querySelector("[lyte-default]");
        if(defaultCase) {
            var isDefCaseTemp = defaultCase.tagName === "TEMPLATE";
            defaultCase.removeAttribute("lyte-default");
            if(defaultCase.hasAttribute("lyte-if")) {
                isDefCaseTemp = false;
                defaultCase = this.handleLyteIf(defaultCase);
            } else if(defaultCase.hasAttribute("lyte-switch")) {
                isDefCaseTemp = false;
                this.handleLyteSwitch(defaultCase);
            }
            if(isDefCaseTemp) {
                template.content.appendChild(defaultCase);
                defaultCase.setAttribute("default" , "");
            } else {
                var defTemp = document.createElement("template");
                defTemp.setAttribute("default" , "");
                defTemp.content.appendChild(defaultCase);
                template.content.appendChild(defTemp);
            }
        }
        template.setAttribute("value", switchValue);
        template.setAttribute("is", "switch");
        if(!type) {
            node.innerHTML = template.outerHTML;
        } else {
            node = template;
        }
    }
/**
 *  @param1 actualComponent - Actual component where we are gonna render the dynamicTemplate.
 *  @param2 templateToRender - clonedNode / String (Which will be converted to DOM) - that needs to be rendered. 
 *  @returnVal rendered dom
 */
Lyte.Component.compileDynamicTemplate = function(actualComponent, templateToRender) {
    if(!actualComponent || !actualComponent.hasAttribute("lyte-rendered")) {
        console.error("Provided element is not a component / not rendered yet")
        return;
    }
    if(!templateToRender) {
        console.error("No template is provided for appending")
        return;
    }
    if(typeof templateToRender === "string") {
        var temp = document.createElement("div");
        temp.innerHTML = templateToRender;
        templateToRender = temp.childNodes[0]; 
    }
    var templateToRenderAct = document.createElement("template");
    //templateToRenderAct.content.appendChild(templateToRender);
    if(Lyte._ie) {
        templateToRenderAct.appendChild(templateToRender);
    } else {
        templateToRenderAct.content.appendChild(templateToRender);    
    }
    var dynamicNodes = Lyte.Compile.getDynamicNodes(actualComponent.tagName, undefined, templateToRenderAct);
    var returnVal = actualComponent.renderNodes(templateToRenderAct, dynamicNodes.dynamicNodes, undefined, {}, true, {}, templateToRenderAct.outerHTML)
    return returnVal;
    
}
/**
 * @param1 func - function to execute without losing bindings
 * @param2 scope - scope with which the function must be executed 
 */
Lyte.Component.doDomProcessing = function(func, scope) {
    LyteComponent.ignoreDisconnect = true;
    if(scope) {
        func.call(scope);
    } else {
        func();    
    }
    LyteComponent.ignoreDisconnect = false;
}

Lyte.Component.getComponentTemplate = function(componentName) {
    var temp = LyteComponent.dummyLyteComponentsDiv.querySelector("template[tag-name='" + componentName + "']");
    if(temp) {
        if(temp.content) {
            return temp.content;    
        } else {
            var div = document.createElement("div")
            div.innerHTML = temp.outerHTML;
            return div.querySelector("template");
        }
    } else {
        console.error("No such component is registered");
        return;
    }
}

Lyte.Compile.getTemplateFromString = function(str, outlet) {
    var div = document.createElement("div");
    div.innerHTML = str;
    div.remove();
    return div.firstChild;
}